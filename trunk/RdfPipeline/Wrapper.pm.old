#! /usr/bin/perl -w 

#file:MyApache2/Chain.pm
#----------------------
# Refresh a file node and then return its content.
#

package MyApache2::Chain;

my $configFile = "/home/dbooth/pcache/pipeline.n3";
my $rulesFile = "/home/dbooth/pcache/rules.n3";
my $prefix = "http://example/pipeline/";	# N3 prefix for properties
$ENV{DOCUMENT_ROOT} ||= "/home/dbooth/pcache/www";	# Set if not set

# See http://perl.apache.org/docs/2.0/user/intro/start_fast.html
use strict;
use warnings;
use Apache2::RequestRec (); # for $r->content_type
use Apache2::SubRequest (); # for $r->internal_redirect
use Apache2::RequestIO ();
use Apache2::Const -compile => qw(OK SERVER_ERROR);

my $logFile = "/tmp/pcache-log.txt";
# unlink $logFile || die;

my $configLastModified = 0;
my $rulesLastModified = 0;
my %config = ();

########## PrintLog ############
sub PrintLog
{
open(my $fh, ">>$logFile") || die;
print $fh @_;
close($fh);
return 1;
}

PrintLog "-" x 60 . "\n";
PrintLog `date`;

use Getopt::Long;
my $debug = 1;
my $test;
&GetOptions("test" => \$test,
	"debug" => \$debug,
	);
PrintLog "ARGV: @ARGV\n" if $test;

my $testUri = shift @ARGV || "http://localhost/chain";
if ($test)
	{
	my $code = &handler("foo");
	PrintLog "\nReturn code: $code\n";
	exit 0;
	}

##################### handler #######################
sub handler 
{
my $ret = &RealHandler(@_);
PrintLog "Handler returning: $ret\n" if $debug;
# return Apache2::Const::OK if $debug;
return $ret;
}

##################### RealHandler #######################
sub RealHandler 
{
my $r = shift;
# $debug = ($r && $r->uri =~ m/c\Z/);
# $r->content_type('text/plain') if $debug && !$test;
if ($debug) {
	PrintLog "Environment variables:\n";
	foreach my $k (sort keys %ENV) {
		PrintLog "$k = " . $ENV{$k} . "\n";
		}
	PrintLog "\n";
	}
PrintLog `date` if $debug;

# Reload config file?
my ($dev,$ino,$mode,$nlink,$uid,$gid,$rdev,$size,
	      $atime,$mtime,$ctime,$blksize,$blocks)
		  = stat($configFile);
# Avoid unused var warning:
($dev,$ino,$mode,$nlink,$uid,$gid,$rdev,$size,
	      $atime,$mtime,$ctime,$blksize,$blocks)
	= ($dev,$ino,$mode,$nlink,$uid,$gid,$rdev,$size,
	      $atime,$mtime,$ctime,$blksize,$blocks);
my $cmtime = $mtime;
($dev,$ino,$mode,$nlink,$uid,$gid,$rdev,$size,
	      $atime,$mtime,$ctime,$blksize,$blocks)
		  = stat($rulesFile);
my $rmtime = $mtime;
if ($configLastModified != $cmtime
		|| $rulesLastModified != $rmtime) {
	# Reload config file.
	PrintLog "Reloading config file: $configFile\n" if $debug;
	$configLastModified = $cmtime;
	$rulesLastModified = $rmtime;
	%config = &CheatLoadN3($rulesFile, $configFile);
	# PrintLog "Got here!\n"; 
	# return Apache2::Const::OK;
	%config || return Apache2::Const::SERVER_ERROR;
	}
if ($debug) {
	PrintLog "Config file $configFile:\n";
	foreach my $k (sort keys %config) {
		PrintLog "$k = " . $config{$k} . "\n";
		}
	PrintLog "\n";
	PrintLog "-" x 60 . "\n" if $debug;
	}
my $thisUri = $testUri;
$thisUri = "http://" . ($r->hostname()) . ($r->uri()) if !$test; 
PrintLog "thisUri: $thisUri\n" if $debug;
my @types = split(/\s+/, ($config{"$thisUri a"}||"") );
PrintLog "ERROR: $thisUri is not a Node.  types: @types\n" if $debug && !(grep {$_ && $_ eq "Node"} @types);
my $subtype = (grep {$_ && $_ ne "Node"} @types)[0] || "";
PrintLog "subtype: $subtype\n" if $debug;
# return Apache2::Const::DECLINED if !$subtype;
return Apache2::Const::SERVER_ERROR if !$subtype;

if ($subtype eq "FileNode") { 
	return &HandleFileNode($r, $thisUri, $config{"$thisUri fileCache"});
	}
elsif ($subtype eq "StdoutNode") { 
	# Not yet implemented
	return Apache2::Const::SERVER_ERROR;
	}
else { return Apache2::Const::SERVER_ERROR; }
}

############## HandleFileNode ###############
# Uses global %config
sub HandleFileNode
{
my $r = shift;
my $thisUri = shift || die;
my $cache = shift || "";
my $inputs = $config{"$thisUri inputs"} || "";
my $parameters = $config{"$thisUri parameters"} || "";
my $dependsOn = $config{"$thisUri dependsOn"} || "";
my $updater = $config{"$thisUri fileUpdater"} || "";
# Make absolute $cache and $updater:
$cache = "/$cache" if $cache && $cache !~ m/\A\\/;
$updater = "$ENV{DOCUMENT_ROOT}/$updater" if $updater && $updater !~ m/\A\\/;
PrintLog "inputs: $inputs\n" if $debug;
PrintLog "parameters: $parameters\n" if $debug;
PrintLog "dependsOn: $dependsOn\n" if $debug;
PrintLog "updater: $updater\n" if $debug;
PrintLog "cache: $cache\n" if $debug;
# fileCache is the only property that is always required for a FileNode:
$cache || return Apache2::Const::SERVER_ERROR;
my $cacheFullPath = $ENV{DOCUMENT_ROOT} . $cache;
PrintLog "cacheFullPath: $cacheFullPath\n" if $debug;
my @inputs = ($inputs ? split(/\s+/, $inputs) : ());
my @parameters = ($parameters ? split(/\s+/, $parameters) : ());
my @dependsOn = ($dependsOn ? split(/\s+/, $dependsOn) : ());
# Run updater if there is one:
if ($updater) {
	if (!-x $updater) {
		PrintLog "ERROR: updater is not executable by web server\n" if $debug;
		PrintLog "Perhaps you need to setuid:  chmod a+s $updater\n";
		}
	my $tmp = "/tmp/updater-out$$";
	my $cmd = "/home/dbooth/pcache/setuid-wrapper $updater $thisUri $cacheFullPath $inputs $parameters > $tmp 2>&1";
	PrintLog "cmd: $cmd\n" if $debug;
	my $result = system($cmd);
	PrintLog "Updater returned $result.  stdout and stderr:\n[[\n" if $debug;
	system "cat $tmp >> $logFile" if $debug;
	unlink $tmp;
	PrintLog "]]\n" if $debug;
	if ($result) {
		PrintLog "UPDATER ERROR: $?\n" if $debug;
		return Apache2::Const::SERVER_ERROR;
		}
	}
elsif (@inputs || @parameters) {
	PrintLog "ERROR: inputs or parameters without an updater.\n" if $debug;
	return Apache2::Const::SERVER_ERROR;
	}
# Finally, read the file cache:
# $r->internal_redirect($cache) if (!$test) && !$debug;
$r->internal_redirect($cache) if !$test;
# These work:
# $r->internal_redirect("/fchain.txt") if !$debug;
# $r->internal_redirect("http://localhost/fchain.txt");
return Apache2::Const::OK;
}

################### AnyChanged #####################
sub AnyChanged
{
my $thisUri = shift @_;
my @supplierUris = @_;
# See if any supplier changed:
foreach my $supplierUri (@supplierUris)
        {
	my (undef, $status) = &GetCached($thisUri, $supplierUri);
        return 1 if $status != URI::Fetch::URI_NOT_MODIFIED();
        }
return 0;
}

################### CheatLoadN3 #####################
# Not proper n3 parsing, but good enough for this purpose.
# Returns a hash map that maps: "$s $p" --> $o
# Global $prefix is also stripped off from terms.
# Example: "http://localhost/a fileCache" --> "c/cp-cache.txt"
sub CheatLoadN3
{
my $rulesFile = shift;
my $configFile = shift;
$configFile || die;
-e $configFile || die;
open(my $fh, "cwm --n3=ps $rulesFile $configFile --think |") || die;
my $nc = " " . join(" ", map { chomp; 
	s/^\s*\#.*//; 		# Strip full line comments
	s/\.(\W)/ .$1/g; 	# Add space before period except in a word
	$_ } <$fh>) . " ";
close($fh);
# PrintLog "-" x 60 . "\n" if $debug;
# PrintLog "nc: $nc\n" if $debug;
# PrintLog "-" x 60 . "\n" if $debug;
while ($nc =~ s/\{[^\}]*\}/ /) {}	# Delete subgraphs: { ... } 
my @triples = grep { m/\S/ } 
	map { s/[()\"]/ /g; 		# Strip: ( ) "
		s/<([^<>\s]+)>/$1/g; 	# Strip < > but Keep empty <>
		s/\A\s+//; s/\s+\Z//; 
		s/\A\s*\@.*//; s/\s\s+/ /g; $_ } 
	split(/\s+\./, $nc);
my $nTriples = scalar @triples;
PrintLog "nTriples: $nTriples\n" if $debug;
# PrintLog "-" x 60 . "\n" if $debug;
# PrintLog "triples: \n" . join("\n", @triples) . "\n" if $debug;
PrintLog "-" x 60 . "\n" if $debug;
my %config = ();
foreach my $t (@triples) {
	# Strip ont prefix from terms:
	$t = join(" ", map { s/\A$prefix([a-zA-Z])/$1/;	$_ }
		split(/\s+/, $t));
	my ($s, $p, $o) = split(/\s+/, $t, 3);
	next if !$o;
	# $o may actually be a space-separate list of URIs
	PrintLog "s: $s p: $p o: $o\n" if $debug;
	# Append additional values for the same property:
	$config{"$s $p"} = "" if !exists($config{"$s $p"});
	$config{"$s $p"} .= " " if $config{"$s $p"};
	$config{"$s $p"} .= $o;
	}
PrintLog "-" x 60 . "\n" if $debug;
return %config;
}

1;

