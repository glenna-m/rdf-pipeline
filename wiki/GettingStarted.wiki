#summary Getting Started

= RDF conventions in pipeline.ttl =
The RDF Pipeline Framework expects pipeline.ttl to obey certain conventions and limitations:
  * pipeline.ttl must be written in Turtle.
  * Blank nodes should only be used implicitly, and only when specifying a list, such as as a list of a node's inputs:
{{{
:foo a p:FileNode ;
  p:inputs ( :bar1 :bar2 :bar3 ) .
}}}

= Updaters: p:updater =
An updater is a program, function or procedure -- the precise nature depends on the node type -- that is associated with a node and _run_ (a/k/a _fired_ or _executed_) when the RDF Pipeline Framework detects that the state of that node should be _refreshed_ (a/k/a _updated, regenerated_ or _freshened_).  By default the node's updater is assumed to exist (as a file) in the $DOCUMENT_ROOT/node directory.  A node's updater may be specified explicitly using p:updater .  However, by default the updater is expected to have the same name as the node, so the following two examples are equivalent:
{{{
# Updater specified explicitly:
:foo a p:FileNode ;
  p:updater "foo" ;
  p:inputs ( :bar1 :bar2 :bar3 ) .

# Updater is implicitly "foo":
:foo a p:FileNode ;
  p:inputs ( :bar1 :bar2 :bar3 ) .
}}}

Every node MUST have an updater.  If you have a data source http://example/coolDataSource that does not need to be updated by the RDF Pipeline Framework, then just make it an input of some other node, without declaring it to be a node:
{{{
:foo a p:FileNode ;
  p:inputs ( <http://example/coolDataSource> ) .
}}}

= Inputs: p:inputs =
A node's inputs are listed using the p:inputs predicate:
{{{
:foo1 a p:FileNode ;
  p:inputs ( :bar1 :bar2 :bar3 ) .

:foo2 a p:FileNode ;
  p:inputs ( :bar1 ) .
}}}

A node with no inputs (or p:dependsOn's, discussed below) will be run only once (to initially freshen its state), and thereafter never again unless: (a) caches are flushed using tools/flush-caches; or (b) the node's updater itself changes, because each node implicitly depends on its updater.  However, as of this writing (see issue #58: http://code.google.com/p/rdf-pipeline/issues/detail?id=58 ), a change to the updater will only be detected if the updater is named explicitly, using p:updater, and is named differently from the node itself, like this:
{{{
# No inputs -- Update only if foo1-updater changes (or caches are flushed)
:foo3 a p:FileNode 
  p:updater "foo1-updater" .
}}}

{{{
# No inputs -- Update only when caches are flushed, which is probably NOT what you want to achieve.
:foo4 a p:FileNode .

# Same as :foo4 example above, but more wordy.
:foo5 a p:FileNode 
  p:updater "foo5" .
}}}


== File inputs ==

File inputs may be specified as inputs in four ways:
{{{
# Input file is $DOCUMENT_ROOT/node/bar.txt (because that's where pipeline.ttl is):
:foo1 a p:FileNode ;
  p:inputs ( <bar.txt> ) .

# Input file is $DOCUMENT_ROOT/node/bar.txt :
:foo2 a p:FileNode ;
  p:inputs ( "bar.txt" ) .

# Input file is $DOCUMENT_ROOT/node/bar.txt :
:foo3 a p:FileNode ;
  p:inputs ( <http://localhost/node/bar.txt> ) .

# Absolute path: input file is /home/dbooth/bar.txt :
:foo4 a p:FileNode ;
  p:inputs ( <file:///home/dbooth/bar.txt> ) .
}}}

*WARNING:* Because of the one-second resolution of Last-Modified headers, if a file changes more than once within the same second, changes after the first may not be detected.  See https://issues.apache.org/bugzilla/show_bug.cgi?id=42987

= Non-input dependencies: p:dependsOn =
Sometimes it is useful to indicate that a node depends on some other node or external source or file without actually requiring that thing's output.  This can be indicated using p:dependsOn .  For example, a node could depend on a clock source, which would cause the node's updater to run every time the node's output is requested (assuming the clock source has changed every time):
{{{
foo: a FileNode ;
  p:inputs ( :bar1 :bar2 :bar3 ) .
  p:dependsOn ( <http://www.timeanddate.com/worldclock/> ) .
}}}