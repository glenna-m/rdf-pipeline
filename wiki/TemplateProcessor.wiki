#summary RDF::Pipeline::Template -- Simple template processor

= RDF::Pipeline::Template -- Simple template processor =
This page was generated by perldoc and pasted into here.

{{{
<pre>
RDF-Pipeline::lib::RDF::Pipeline::Template(3)3)



NAME
       RDF::Pipeline::Template - Perl extension for very simple template
       substitution.

SYNOPSIS
       From the command line:

         ste.perl [options...] [template]

       with typical options (explained more fully below):
        -i iVal1      Provide #inputs value iVal1
        -o oVal1      Provide #outputs value oVal1
        -p pVar1=pVal1 Set QUERY_STRING to pVar1=pVal1

       Or for use as a module, by a perl program:

         use RDF::Pipeline::Template qw( :all );
         my $result = &ProcessTemplate($template, \@ins, \@outs,
                       $queryString, $thisUri);

DESCRIPTION
       This page documents both the RDF::Pipeline::Template module and
       ste.perl, which is a tiny shell script that merely invokes the module.

       This module provides a very simple template substitution facility.  It
       was intended primarily for writing SPARQL query templates for use in
       the context of the RDF Pipeline Framework, but can be used for other
       things.  It knows nothing about SPARQL syntax.

       Template processing involves replacing template variables with values,
       which may be arbitrary strings.  No looping, conditional or other
       features are provided.  Template variables include those that are
       declared explicitly, as described next, and environment variables,
       described later.

   Declaring Template Variables
       Template variables are declared within a template using lines like
       this:

         #inputs ( iVar1 iVar2 ... iVarN )
         #outputs ( oVar1 oVar2 ... oVarN )
         #parameters ( pVar1 pVar2 ... pVarN )

       This declares variables iVar1 ... iVarN, oVar1 ... oVarN and pVar1 ...
       pVarN for use within the template.  Values may be provided when the
       template is processed, as explained later.  Each of these lines is
       optional and is removed when the template is processed.

       The hash (#) MUST be the first character of the line.  Whitespace is
       required between variable names, and is optional around the
       parentheses.  Variable names specified in #inputs or #outputs can use
       any syntax except whitespace or parentheses, i.e., they must match the
       following Perl regular expression (where \s is any whitespace):

         [^()\s]+

       However, common variable syntax conventions like $foo , ${foo} or %foo%
       are a good idea for both safety and readability.   On the other hand,
       you could use a string like http://example/var# as a variable name,
       which would give you the effect of replacing that string throughout
       your template when the template is processed.

       The #inputs and #outputs directives have exactly the same function
       unless you are using the RDF Pipeline Framework, in which case #inputs
       is used to specify a node's inputs and #outputs specifies its outputs.

       The syntax of #parameters variables is further restricted because of
       the way they are set (via query string parameters, as described below).
       #parameters variables must be composed of "word" characters, optionally
       surrounded by non-"word" characters, i.e., they must match the
       following Perl regular expression (where \w means [0-9a-zA-Z_]):

         [^()\s\w]*\w+[^()\s\w]*

       The non-word characters are ignored when looking for the corresponding
       query string variable, as further described below, so ${foo} and %foo%
       both correspond to query string variable foo.

   Value Substitution
       When a template is processed, values are substituted for all #inputs,
       #outputs, #parameters and environment variables that appear in the
       template, as described below.  If a value is not supplied for a
       variable, then the empty string is silently substituted.

       The template processor has no idea what you are intending to generate,
       and values may be any text (limited in size only by memory), so for the
       most part this is blind text substitution.

       WARNING: If you are using this template system to generate queries,
       commands, HTML or anything else that could be dangerous if
       inappropriate text were injected, then you should be careful to scrub
       your values before invoking this template processor.

       Also, although bare words (or numbers!) are allowed as variable names,
       they are usually not a good idea, because it is too easy to make a
       mistake like writing the following:

         #inputs( givenName )
         SELECT *
         WHERE { ?name foaf:givenName "givenName" }

       which, when givenName has the value "Bill", will silently become:

         SELECT *
         WHERE { ?name foaf:Bill "Bill" }

       which is probably NOT what you intended.

       There is one small exception to this blind substitution: the template
       processor will not break a word in the template.  This means that you
       can safely use a variable name like $f without fear that it will be
       substituted into template text containing the string $fred.
       Specifically, a variable beginning or ending with a Perl "word"
       character [a-zA-Z0-9_] will have the Perl regular expression assertion
       \b (see http://perldoc.perl.org/perlre.html#Assertions ) prepended or
       appended (or both) to the substitution pattern, thus forcing the match
       to only occur on a word boundary.  Template processing can, however,
       cause words to be joined together.  For example, if template variable
       ${eff} has the value PH , then a template string "ELE${eff}ANT" will
       become "ELEPHANT".

   Supplying Values for Template Variables
       The way to supply a value for a template variable depends on what kind
       of template variable it is.

       #inputs or #outputs variables
           Any #inputs or #outputs variables are set using the -i or -o
           command-line options, respectively, or passed in array references
           if you are calling &ProcessTemplate directly from Perl.  Values are
           supplied positionally: the value specified by the nth -i option (or
           -o option) is bound to the nth #inputs (or #outputs) variable,
           respectively.

       #parameters variables
           By default #parameters variables are set through the $QUERY_STRING
           environment variable, which is assumed to provide an ampersand-
           delimited list of key=value pairs.  Per
           http://www.w3.org/TR/1999/REC-html401-19991224/appendix/notes.html#h-B.2.2
           a semicolon can also be used as a delimiter instead of ampersand.
           Both keys and values are URI decoded during template processing,
           i.e., any %-encodings are decoded.

           Non-word characters (i.e., [^a-zA-Z0-9_]) in a #parameters variable
           are ignored when looking up the corresponding key in the
           $QUERY_STRING.  For example, parameters $min and ${max} that are
           declared in a template as:

             #parameters ( $min ${max} )
             . . .
             FILTER( ?n >= $min && ?n <= ${max} )

           correspond to keys min and max in a $QUERY_STRING such as
           min=2&max=99 , yielding the following result:

             . . .
             FILTER( ?n >= 2 && ?n <= 99 )

           Parameter variables may also be set via the -p command-line option,
           which sets the QUERY_STRING environment variable (explained below).

           If you are calling &ProcessTemplate directly from Perl, then
           parameter values are supplied in a $queryString argument as a
           string, which has the exact same syntax as the $QUERY_STRING.

           If you specify the same variable name twice, such as in
           min=2&max=99&min=5 , the earlier value will be silently ignored, so
           $min will be 5.

   ACCESSING ENVIRONMENT VARIABLES
       In addition to any #inputs, #outputs or #parameters variables that you
       declare explicitly as described above, a template can access the values
       of environment variables, using a fixed syntax.

       $ENV{VAR}
           For any environment variable $VAR, $ENV{VAR} will be replaced with
           the value of the $VAR environment variable (if set) or the empty
           string (if unset).

       $ENV{QUERY_STRING}
           This is a special case of $ENV{VAR}.  $ENV{QUERY_STRING} will be
           replaced with the value of the $QUERY_STRING environment variable
           (if set) or the empty string (if unset).   This is useful if you
           need access to the raw $QUERY_STRING.  Normally it is not needed,
           because #parameters variables are set from the $QUERY_STRING
           environment variable.  See the -p option of ste.perl.

       $ENV{THIS_URI}
           This is another special case of $ENV{VAR}.  $ENV{THIS_URI} will be
           replaced with the value of the $THIS_URI environment variable (if
           set) or the empty string (if unset).   See the -t option of
           ste.perl.

   EXAMPLE
       Here is a complete template example, sample-template.txt, that
       illustrates the features:

         #inputs ( $inUri Bill ${Taft} )
         #outputs ( $outUri )
         #parameters ( $max $min )
         Testing inputs, outputs:
           inUri: $inUri
           B_i_l_l: Bill  "Bill"  money@Bill.me
           Taft: ${Taft}
         Testing parameters (either from QUERY_STRING or from -p option):
           min: $min
           max: $max
         Testing environment variables:
           THIS_URI: $ENV{THIS_URI}
           FOO: $ENV{FOO}
         Testing the QUERY_STRING:
           $ENV{QUERY_STRING}
         Note that the following are NOT changed, because template
         processing will NOT break words, and it is case sensitive:
           $inUriExtra  Billion  EmBill bill

       If this template is processed using the following shell commands:

         export QUERY_STRING='min=2&max=99'
         ./ste.perl sample-template.txt -t http://example/this -i http://example/in -i William -i Taffy -o http://example/out

       then the following result will be written to STDOUT:

         Testing inputs, outputs:
           inUri: http://example/in
           B_i_l_l: William  "William"  money@William.me
           Taft: Taffy
         Testing parameters (either from QUERY_STRING or from -p option):
           min: 2
           max: 99
         Testing environment variables:
           THIS_URI: http://example/this
           FOO:
         Testing the QUERY_STRING:
           min=2&max=99
         Note that the following are NOT changed, because template
         processing will NOT break words, and it is case sensitive:
           $inUriExtra  Billion  EmBill bill

   EXPORT
       None by default.

COMMAND LINE OPTIONS
       When this module is run from the command line (as ste.perl) it has the
       following options:

       -i iValueN
           Provides a value for an #inputs variable.  This option should be
           repeated once for each variable in the #inputs list: the nth -i
           option supplies the value for the nth #inputs variable.  For
           example, given two variables $x and $y:

             #inputs( $x $y )

           to set $x to 5 and $y to 10, the -i option should be used twice:

             ste.perl -i 5 -i 10

       -o iValueN
           Like the -i option, but for #outputs variables.

       -p pVar1=pVal1&pVar2=pVal2 ...
           Sets the QUERY_STRING environment variable to provide URI encoded
           key/value pairs to be substituted into variables specified by the
           "#parameters( $pVar1 $pVar2 ... )" line in template.  Both keys and
           values will be uri_unescaped before variable substitution.
           Multiple key=value pairs may be specified together using "&" or ";"
           as separator, such as: foo=bar&fum=bah&foe=bif .  If the -p option
           is not used, then URI-encoded variable/value pairs will be taken
           from the QUERY_STRING environment variable.  This option may be
           repeated, in which case the given key=value pairs will be
           concatenated into a single $QUERY_STRING, with ampersand as a
           separator.  Variable order is not significant unless the same
           variable appears more than once in $QUERY_STRING, in which case the
           last value is silently used.

       -t thisUri
           Sets the THIS_URI environment variable to thisUri, which causes
           thisUri to be substituted for $ENV{THIS_URI} in template.

SEE ALSO
       RDF Pipeline Framework: http://code.google.com/p/rdf-pipeline/

AUTHOR
       David Booth <david@dbooth.org>

COPYRIGHT AND LICENSE
       Copyright 2011 & 2012 David Booth <david@dbooth.org> See license
       information at http://code.google.com/p/rdf-pipeline/



RDF-Pipeline::lib::RDF::Pipeline::Template(3)
</pre>
}}}